
# Shared Memory Simulator 

## Overview

This simulator enables testing `ls_motor.c` without EtherCAT hardware or libfakeethercat. It uses POSIX shared memory for direct PDO exchange.

---

## Core Simulator Files

### 1. shm_sim.c (332 lines)
**Purpose**: Standalone EtherCAT simulator with CiA 402 state machine

**Key Features**:
- POSIX shared memory interface (`/ethercat_sim_pdo`)
- Full motor state machine (6 states: NOT_READY → SWITCH_ON_DISABLED → READY_TO_SWITCH_ON → SWITCHED_ON → OPERATION_ENABLED → QUICK_STOP)
- Simulates motor physics (position, velocity, torque)
- Mutex-protected thread-safe access
- 10ms cycle time (configurable)

**Compilation**:
```bash
gcc -Wall -O2 -g -o shm_sim shm_sim.c -lpthread -lrt
```

**Usage**:
```bash
./shm_sim
```

**Output**:
```
Cycle   300: State=2, CW=0x0006, SW=0x0221, Pos=0, Vel=0, Trq=0
Motor: State transition 2 -> 3 (CW: 0x0007)
```

---

### 2. ecrt_shm_shim.c (230 lines)
**Purpose**: EtherCAT API shim library that redirects ecrt_* calls to shared memory

**Implements**:
- `ecrt_request_master()` - Returns dummy pointer
- `ecrt_master_create_domain()` - Returns dummy pointer
- `ecrt_slave_config_pdos()` - Logs configuration
- `ecrt_domain_reg_pdo_entry_list()` - Maps PDO offsets
- `ecrt_master_activate()` - **Opens shared memory** (`shm_open`, `mmap`)
- `ecrt_domain_process()` - **Reads from SHM** (Status Word, Position, Velocity, Torque)
- `ecrt_domain_queue()` - **Writes to SHM** (Control Word, Target Torque, Mode)
- `ecrt_master_send/receive()` - No-op
- SDO stubs (return success)

**Compilation**:
```bash
gcc -shared -fPIC -Wall -O2 -I/usr/local/include \
    -o libecrt_shm.so ecrt_shm_shim.c -lpthread -lrt
```

**Result**: `libecrt_shm.so` (shared library)

---

### 3. Shared Memory Structure

Defined in both `shm_sim.c` and `ecrt_shm_shim.c`:

```c
typedef struct {
    // Master → Simulator (3 bytes + padding)
    uint16_t control_word;      // Offset 0
    int16_t target_torque;      // Offset 2
    int8_t operation_mode;      // Offset 4
    
    // Simulator → Master (18 bytes)
    uint16_t error_code;        // Read-only
    uint16_t status_word;       // Offset 5
    int8_t mode_display;        // Offset 7
    int32_t actual_position;    // Offset 8
    int32_t actual_velocity;    // Offset 12
    int32_t following_error;    // Read-only
    int16_t actual_torque;      // Offset 16
    
    // Synchronization
    pthread_mutex_t mutex;
    uint32_t master_cycle_count;
    uint32_t sim_cycle_count;
    bool initialized;
} shm_pdo_t;  // Total: 83 bytes
```

**Location**: `/dev/shm/ethercat_sim_pdo`

---

## Test Utilities

### 4. shm_wrapper.h (107 lines)
**Purpose**: Simplified API for C applications (alternative to shim library)

**Functions**:
- `int shm_init()` - Open shared memory
- `void shm_read(...)` - Read all inputs
- `void shm_write(...)` - Write all outputs
- `void shm_cleanup()` - Unmap and close
- `void shm_print_stats()` - Print cycle counts

**Usage**:
```c
#include "shm_wrapper.h"

shm_init();
shm_write(0x0006, 0, 10);  // Shutdown command
shm_read(&status, &mode, &pos, &vel, &trq);
shm_cleanup();
```

---

### 5. shm_test_client.c (Generated by test_shm.sh)
**Purpose**: Standalone test client demonstrating servo enable sequence

**Test Sequence**:
1. Shutdown (0x0006) → Wait for Ready to Switch On (0x0221)
2. Switch On (0x0007) → Wait for Switched On (0x0223)
3. Enable Operation (0x000F) → Wait for Operation Enabled (0x0627)
4. Apply torque commands

**Compilation**:
```bash
gcc -Wall -O2 -o shm_test_client shm_test_client.c -lpthread -lrt
```

---

## Integration Scripts

### 6. test_ls_motor_shm.sh (55 lines)
**Purpose**: Automated test script for `ls_motor.c` with shim

**Steps**:
1. Build `libecrt_shm.so` from `ecrt_shm_shim.c`
2. Compile `ls_motor.c` → `ls_motor_shm` (linked with shim)
3. Start `shm_sim` in background
4. Run `ls_motor_shm 1`
5. Check for success keywords
6. Display logs

**Usage**:
```bash
chmod +x test_ls_motor_shm.sh
./test_ls_motor_shm.sh
```

**Output**:
```
✅ SUCCESS - Motor enabled!
```

---

### 7. test_shm.sh (Older version, 80 lines)
**Purpose**: Test script for standalone client (not ls_motor)

Creates and runs `shm_test_client.c` inline.

---

## Documentation

### 8. TESTING.md
**Purpose**: User guide for manual and automated testing

**Sections**:
- Quick Start
- Manual Testing (2 terminals)
- How It Works (architecture diagram)
- Files Created
- Cleanup
- Troubleshooting

---

## File Summary Table

| File | Lines | Purpose | Compiles To |
|------|-------|---------|-------------|
| `shm_sim.c` | 332 | Standalone simulator | `shm_sim` (28KB) |
| `ecrt_shm_shim.c` | 230 | EtherCAT API shim | `libecrt_shm.so` (18KB) |
| `shm_wrapper.h` | 107 | Simplified API | Header only |
| `shm_test_client.c` | ~120 | Test client | `shm_test_client` (17KB) |
| `test_ls_motor_shm.sh` | 55 | Automated test | Script |
| `test_shm.sh` | 80 | Client test | Script |
| `TESTING.md` | - | Documentation | - |

---

## Complete Build and Test Commands

```bash
# 1. Build simulator
gcc -Wall -O2 -g -o shm_sim shm_sim.c -lpthread -lrt

# 2. Build shim library
gcc -shared -fPIC -Wall -O2 -I/usr/local/include \
    -o libecrt_shm.so ecrt_shm_shim.c -lpthread -lrt

# 3. Compile ls_motor with shim
gcc -Wall -O2 -g -D_GNU_SOURCE -I/usr/local/include \
    -o ls_motor_shm ls_motor.c \
    -L. -lecrt_shm -lpthread -lrt -lm -Wl,-rpath,.

# 4. Test
./shm_sim &           # Terminal 1
./ls_motor_shm 1      # Terminal 2
```

**Or use automated script**:
```bash
./test_ls_motor_shm.sh
```

---

## Data Flow Architecture

```
┌─────────────────────────────────────────────────────┐
│ ls_motor.c (unchanged)                              │
│   - Calls ecrt_domain_process()                     │
│   - Calls ecrt_domain_queue()                       │
│   - Reads/writes domain_pd buffer                   │
└────────────────┬────────────────────────────────────┘
                 │ ecrt_* API calls
                 ▼
┌─────────────────────────────────────────────────────┐
│ libecrt_shm.so (shim)                               │
│   - Intercepts ecrt_* functions                     │
│   - Maintains local domain_pd buffer                │
│   - process(): SHM → domain_pd                      │
│   - queue(): domain_pd → SHM                        │
└────────────────┬────────────────────────────────────┘
                 │ pthread_mutex_lock/unlock
                 │ read/write shm_pdo_t
                 ▼
┌─────────────────────────────────────────────────────┐
│ /dev/shm/ethercat_sim_pdo (83 bytes)                │
│   - control_word, target_torque, operation_mode     │
│   - status_word, position, velocity, torque         │
│   - pthread_mutex (process-shared)                  │
└────────────────┬────────────────────────────────────┘
                 │ pthread_mutex_lock/unlock
                 │ read/write shm_pdo_t
                 ▼
┌─────────────────────────────────────────────────────┐
│ shm_sim (standalone)                                │
│   - Reads control_word                              │
│   - Updates state machine                           │
│   - Simulates motor physics                         │
│   - Writes status_word, position, velocity, torque  │
└─────────────────────────────────────────────────────┘
```

---

## Key Advantages

✅ **No libfakeethercat** - Bypasses RtIPC complexity  
✅ **No code changes** - ls_motor.c works unmodified  
✅ **Simple debugging** - Direct memory access, clear flow  
✅ **Fast** - Sub-millisecond latency  
✅ **Portable** - Standard POSIX, works anywhere  
✅ **Proven** - Successfully enables servo (0x0627 status)

---

## Logs and Output Files

Generated during testing:
- `ls_motor_test.log` - Master application output
- `ls_motor_sim.log` - Simulator output
- `shm_sim.log` - Simulator debug log
- `client_verify.log` - Test client results
- `sim_verify.log` - Verification run logs
